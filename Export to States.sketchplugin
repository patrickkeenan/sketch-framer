// Sketch Framer (ctrl alt command s)

/* Import the variables and complain if they are undefined */
#import 'sketch-framer-config.js'

/*
This is a port to JSTalk of <https://github.com/leighmcculloch/AppSandboxFileAccess>

Here's the original license for AppSandboxFileAccess:

## License

Copyright (c) 2013, Leigh McCulloch All rights reserved.

BSD-2-Clause License: http://opensource.org/licenses/BSD-2-Clause

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var AppSandboxFileAccessPersist = {
  keyForBookmarkDataForURL: function(url) {
    log("AppSandboxFileAccessPersist.keyForBookmarkDataForURL("+url+")")
    var urlStr = [url absoluteString];
    log("> " + [NSString stringWithFormat:@"bd_%1$@", urlStr])
    return [NSString stringWithFormat:@"bd_%1$@", urlStr];
  },
  bookmarkDataForURL: function(url) {
    log("AppSandboxFileAccessPersist.bookmarkDataForURL('"+ url +"')")
    var defaults = [NSUserDefaults standardUserDefaults];

    // loop through the bookmarks one path at a time down the URL
    var subUrl = url;
    while ([subUrl path].length > 1) { // give up when only '/' is left in the path
      var key = AppSandboxFileAccessPersist.keyForBookmarkDataForURL(subUrl);
      var bookmark = [defaults dataForKey:key];
      if (bookmark) { // if a bookmark is found, return it
        return bookmark;
      }
      subUrl = [subUrl URLByDeletingLastPathComponent];
    }
    // no bookmarks for the URL, or parent to the URL were found
    return nil;
  },
  setBookmarkData: function(data, url) {
    log("AppSandboxFileAccessPersist.setBookmarkData")
    log("data: " + data)
    log("URL: " + url)
    var defaults = [NSUserDefaults standardUserDefaults];
    var key = AppSandboxFileAccessPersist.keyForBookmarkDataForURL(url);
    [defaults setObject:data forKey:key];
  }
}

var AppSandboxFileAccess = {
  init: function(opts){
    this.message = opts.message || "Please authorize Sketch to write to this folder. You will only need to do this once."
    this.prompt = opts.prompt || "Authorize",
    this.title = opts.title || "Sketch Authorization"
    return this;
  },
  askPermissionForUrl: function(url) {
    log("AppSandboxFileAccess.askPermissionForUrl("+url+")")
    // this url will be the url allowed, it might be a parent url of the url passed in
    var allowedUrl;

    // create delegate that will limit which files in the open panel can be selected, to ensure only a folder
    // or file giving permission to the file requested can be selected
    // AppSandboxFileAccessOpenSavePanelDelegate *openPanelDelegate = [[AppSandboxFileAccessOpenSavePanelDelegate alloc] initWithFileURL:url];

    // check that the url exists, if it doesn't, find the parent path of the url that does exist and ask permission for that
    var fileManager = [NSFileManager defaultManager];
    var path = [url path];
    while (path.length > 1) { // give up when only '/' is left in the path or if we get to a path that exists
      if ([fileManager fileExistsAtPath:path]) {
        break;
      }
      path = [path stringByDeletingLastPathComponent];
    }
    log("Looks like we have a winner: " + path)
    url = [NSURL fileURLWithPath:path];

    // display the open panel
    var openPanel = [NSOpenPanel openPanel];
    [openPanel setMessage:this.message];
    [openPanel setPrompt:this.prompt];
    [openPanel setTitle:this.title];
    // [openPanel setDelegate:openPanelDelegate];
    [openPanel setCanCreateDirectories:NO];
    [openPanel setCanChooseFiles:YES];
    [openPanel setCanChooseDirectories:YES];
    [openPanel setAllowsMultipleSelection:NO];
    [openPanel setShowsHiddenFiles:NO];
    [openPanel setExtensionHidden:NO];
    [openPanel setDirectoryURL:url];
    [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
    var openPanelButtonPressed = [openPanel runModal];
    if (openPanelButtonPressed == NSFileHandlingPanelOKButton) {
      allowedUrl = [openPanel URL];
    }
    return allowedUrl;
  },
  persistPermissionPath: function(path) {
    this.persistPermissionURL([NSURL fileURLWithPath:path]);
  },
  persistPermissionURL: function(url) {
    log("AppSandboxFileAccess.persistPermissionURL("+url+")")
    // store the sandbox permissions
    url = [[url URLByStandardizingPath] URLByResolvingSymlinksInPath]
    var bookmarkData = [url bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
                           includingResourceValuesForKeys:nil
                           relativeToURL:nil
                           error:null];
    if (bookmarkData) {
      AppSandboxFileAccessPersist.setBookmarkData(bookmarkData, url);
    }
  },
  accessFilePath_withBlock_persistPermission: function(path, block, persist) {
    log("AppSandboxFileAccess.accessFilePath_withBlock_persistPermission")
    log("path: " + path)
    return AppSandboxFileAccess.accessFileURL_withBlock_persistPermission([NSURL fileURLWithPath:path], block, persist);
  },
  accessFileURL_withBlock_persistPermission: function(fileUrl, block, persist) {
    log("AppSandboxFileAccess.accessFileURL_withBlock_persistPermission")
    log("fileUrl: " + fileUrl)
    log("block: " + block)
    log("persist: " + persist)
    var allowedUrl = false;
    // standardize the file url and remove any symlinks so that the url we lookup in bookmark data would match a url given by the askPermissionForUrl method
    var fileUrl = [[fileUrl URLByStandardizingPath] URLByResolvingSymlinksInPath];
    // lookup bookmark data for this url, this will automatically load bookmark data for a parent path if we have it
    var bookmarkData = AppSandboxFileAccessPersist.bookmarkDataForURL(fileUrl);

    if (bookmarkData) {
      log("Bookmark data found")
      // resolve the bookmark data into an NSURL object that will allow us to use the file
      var bookmarkDataIsStale;
      allowedUrl = [NSURL URLByResolvingBookmarkData:bookmarkData options:NSURLBookmarkResolutionWithSecurityScope|NSURLBookmarkResolutionWithoutUI relativeToURL:nil bookmarkDataIsStale:bookmarkDataIsStale error:null];
      // if the bookmark data is stale, we'll create new bookmark data further down
      if (bookmarkDataIsStale) {
        bookmarkData = nil;
      }
    } else {
      log("No bookmark data found")
    }

    // if allowed url is nil, we need to ask the user for permission
    if (!allowedUrl) {
      allowedUrl = AppSandboxFileAccess.askPermissionForUrl(fileUrl);
      if (!allowedUrl) {
        // if the user did not give permission, exit out here
        return false;
      }
    }
    // if we have no bookmark data, we need to create it, this may be because our bookmark data was stale, or this is the first time being given permission
    if (persist && !bookmarkData) {
      AppSandboxFileAccess.persistPermissionURL(allowedUrl);
    }
    // execute the block with the file access permissions
    try {
      [allowedUrl startAccessingSecurityScopedResource];
      block();
    } finally {
      [allowedUrl stopAccessingSecurityScopedResource];
    }
    return true;
  }
}
function in_sandbox(){
  var environ = [[NSProcessInfo processInfo] environment];
  return (nil != [environ objectForKey:@"APP_SANDBOX_CONTAINER_ID"]);
}
var sandboxAccess = AppSandboxFileAccess.init({
  message: "Please authorize Sketch to write to this folder. You will only need to do this once per folder.",
  prompt:  "Authorize",
  title: "Sketch Authorization"
})


/* Configuration */
var framerjs_url = "https://raw.github.com/koenbok/Framer/master/build/framer.js";

function should_become_view(layer) {
  return is_group(layer) || [layer name].slice(-1) == '+';
}
function is_group(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
}
function is_bitmap(layer) {
  return [layer isMemberOfClass:[MSBitmapLayer class]]
}
function should_ignore_layer(layer) {
  return [layer name].slice(-1) == '-' || [layer className] == "MSPage";
}
function sanitize_filename(name){
  return name.replace(/(\s|:|\/)/g ,"_").replace(/__/g,"_").replace("*","").replace("+","").replace("&","");
}
function has_art(layer) {
  // return true;
  if(is_group(layer) && !should_flatten_layer(layer)) {
    var has_art = false;

    var sublayers = [layer layers];
    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
      var sublayer = sublayers[sub];
      if(!should_ignore_layer(sublayer) && !should_become_view(sublayer)) {
        has_art = true;
      }
    }
    return has_art;

  } else {
    return true;
  }
}
function should_flatten_layer(layer) {
  var name = [layer name];
  if(name.slice(-1) == "*") {
    return true;
  } else {
    return false;
  }
}
function log_depth(message, depth) {
  var padding = "";
  for(var i=0; i<depth; i++) {
    padding += ">"
  }
  log(padding + " " + message);
}

function save_file_from_string(filename,the_string) {
  log("save_file_from_string("+filename+")")
  var path = [@"" stringByAppendingString:filename],
      str = [@"" stringByAppendingString:the_string];

  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission(filename, function(){
      [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:null];
    }, true)
  } else {
    [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:null];
  }
}

function mask_bounds(layer) {
  var sublayers = [layer layers];

  for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
    var current = sublayers[sub];
    if(current.hasClippingMask()) {
      var maskParentFrame = layer.frame();
      var metadataForMask = metadata_for(current);

      [current setHasClippingMask:false]
      layer.resizeRoot()

      metadataForMask.x = metadataForMask.x - maskParentFrame.x()
      metadataForMask.y = metadataForMask.y - maskParentFrame.y()
      [current setHasClippingMask:true]
      log('Found mask: '+current)
      return metadataForMask;
    }
  }

  return null;
}
function calculate_real_position_for(layer) {

  var gkrect = [GKRect rectWithRect:[layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]],
      absrect = [layer absoluteRect];

  var rulerDeltaX = [absrect rulerX] - [absrect x],
      rulerDeltaY = [absrect rulerY] - [absrect y],
      GKRectRulerX = [gkrect x] + rulerDeltaX,
      GKRectRulerY = [gkrect y] + rulerDeltaY;

  return {
    x: Math.round(GKRectRulerX),
    y: Math.round(GKRectRulerY)
  }
}
function metadata_for(layer) {
  log("metadata_for("+layer+")")
  var frame = [layer frame];
  var gkrect = [GKRect rectWithRect:[layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]];
  log("rect "+gkrect)
  var absrect = [layer absoluteRect];
  var position = calculate_real_position_for(layer);
  var x,y,w,h,r;

      if ([layer className] == "MSArtboardGroup") {
        // FIXME: This is probably still wrong, test with different artboard positions
        x = [[layer absoluteRect] rulerX],
        y = [[layer absoluteRect] rulerY],
        w = [frame width],
        h = [frame height],
        r = {
          x: x,
          y: y,
          width: w,
          height: h
        }
      } else {
        x = position.x,
        y = position.y,
        w = [gkrect width],
        h = [gkrect height],
        r = {
          x: x,
          y: y,
          width: w,
          height: h
        }
      }

  log(JSON.stringify(r))

  return r
}
function extract_metadata_from(layer) {
  log("extract_metadata_from("+layer+")")
  var layerFrame = metadata_for(layer)
  log(layerFrame)
  var maskFrame = mask_bounds(layer)

  log("maskFrame: " + maskFrame)
  if(maskFrame){
    log(JSON.stringify(maskFrame))
  }

  // - Get style data, specfically opacity
  var layerStyle = layer.style();
  layerFrame.opacity = layerStyle.contextSettings().opacity();
  layerFrame.rotationZ = layer.rotation();

  var styles = extract_style_from(layer)
  for(var attr in styles){
    layerFrame[attr] = styles[attr]
  }

  var shadow = extract_shadow_from(layer)

  if(shadow){
    layerFrame.boxShadow = shadow;
    log('putting shadow into styles attr'+shadow)
  }
  

  var metadata = {
    name: sanitize_filename([layer name]),
    layerFrame: layerFrame
    // id: [layer objectID]
  }

  if (maskFrame) {
    metadata.maskFrame = maskFrame
  }

  if(has_art(layer)) {
    metadata.image = {
      path: "images/" + sanitize_filename([layer name]) + ".png",
      frame: layerFrame
    };
    metadata.imageType = "png";
    // TODO: Find out how the modification hash is calculated in Framer.app
    // metadata.modification = new Date();
  }

  // if it was invisible, mark this in the metadata as well
  if ([layer name].slice(-1) == '&') {
    metadata.visible = false
  }

  return metadata;
}
function extract_shadow_from(layer) {
  //TODO: Get the blur properties
  var styles = {}
  var styleObjects = layer.style().shadows().array()
  log('Checking shadow'+styles)

  var CSSShadow=false;
  
  for(var i=0;i<styleObjects.length;i++){
    log('Found shadow'+styleObjects[i])
    var shadowObject =styleObjects[i]
    var shadowColor='rgba('
      +Math.round(shadowObject.color().red()*255)+','
      +Math.round(shadowObject.color().green()*255)+','
      +Math.round(shadowObject.color().blue()*255)+','
      +shadowObject.color().alpha()+')'
    CSSShadow = shadowObject.offsetX()+'px '+shadowObject.offsetY()+'px '+shadowObject.blurRadius()+'px '+shadowObject.spread()+'px '+shadowColor;
    
    //layer.style().shadows().removeStylePart(shadowObject)
  }
  return CSSShadow;

}

function extract_style_from(shapeLayer) {
  /*
  var styles = {}
  var borders = shapeLayer.style().borders().array()

  log('CSS Box:  '+ shapeLayer.CSSAttributeString().toString()+' ')
  for(var borderIndex = 0; borderIndex < borders.length; borderIndex++){
    var border = borders[borderIndex]
    log('CSS Box border is  '+ border)
    styles.borderSize = border.thickness();
    styles.borderColor = 'rgba('
      +Math.round(border.color().red()*255)+','
      +Math.round(border.color().green()*255)+','
      +Math.round(border.color().blue()*255)+','
      +border.color().alpha()+')'
    
    log('CSS Box border position:  '+ border.position())
    log('CSS Box border fillType:  '+ border.fillType())
    log('CSS Box border gradient:  '+ border.gradient())
    log('CSS Box border isEnabled:  '+ border.isEnabled())
    log('CSS Box border red:  '+ border.color().red())
    log('CSS Box border blue:  '+ border.color().blue())
    log('CSS Box border green:  '+ border.color().green())
    log('CSS Box border alpha:  '+ border.color().alpha())
    
  }

  var fills = shapeLayer.style().fills().array()
  log('CSS Box has fills  '+ fills.length)
  for(var fillIndex = 0; fillIndex < fills.length; fillIndex++){
    var fill = fills[fillIndex]
    styles.backgroundColor = 'rgba('
      +Math.round(fill.color().red()*255)+','
      +Math.round(fill.color().green()*255)+','
      +Math.round(fill.color().blue()*255)+','
      +fill.color().alpha()+')'
    log('CSS Box fill is  '+ fill)
    log('CSS Box fill fillType:  '+ fill.fillType())
    log('CSS Box fill red:  '+ fill.color().red())
    log('CSS Box fill blue:  '+ fill.color().blue())
    log('CSS Box fill green:  '+ fill.color().green())
    log('CSS Box fill alpha:  '+ fill.color().alpha())
    log('CSS Box fill gradient:  '+ fill.gradient())
    log('CSS Box fill isEnabled:  '+ fill.isEnabled())
  }
  */

  var CSSString = shapeLayer.CSSAttributeString().toString();
  var styles ={}

  var stylestemp = CSSString.split('\n');
  
  for (var i = 0; i < stylestemp.length ; i++) {

    var values = stylestemp[i].split(':');
    
    if(values.length>1 && stylestemp[i].indexOf('//')==-1 && stylestemp[i].indexOf('/*')==-1){
      var attr = values[0].replace( /-(\w)/g, function _replace( $1, $2 ) {return $2.toUpperCase();});
      var val = values[1].replace(';','')
      log('style values'+attr+':'+values[1].replace(';',''));
      styles[attr] = val;
    }
    
  } 
  

  //return styles; 
  return styles
  //+'\n-webkit-transform: rotateZ('+shapeLayer.rotation()+'deg);'

}

function make_folder(path){
  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission(path, function(){
      [file_manager createDirectoryAtPath:path withIntermediateDirectories:true attributes:nil error:nil];
    },true)
  } else {
    [file_manager createDirectoryAtPath:path withIntermediateDirectories:true attributes:nil error:nil];
  }
}
function make_folders(){
  // Create folders
  var folders = [target_folder,images_folder,framer_folder]
  for (var i = 0; i < folders.length; i++) {
    make_folder(folders[i])
  }
}

function process_all_layers(page){
  var all_layers = [page layers]

  for (var i=0; i < [all_layers count]; i++) {
    process_layer(page, all_layers[i],project_metadata, 0);
  }
}
function process_all_artboards(page){
  var all_artboards = [page artboards];
  var artboardCount = [all_artboards count]
  log('Multistate: Exporting boards'+all_artboards+' '+artboardCount)
  
  for (var artboardId = artboardCount-1; artboardId >= 0; artboardId-- ){
    var thisArtboard = all_artboards[artboardId]
    var all_layers = [thisArtboard layers];
    var artboardName = [thisArtboard name];
    
    var SanitizedArtboardName = sanitize_filename(artboardName);
    states_metadata[SanitizedArtboardName] = {};

    var artboard_metadata = [];
    process_layer(page, thisArtboard,artboard_metadata, 0, true);
    log('Multistate: Processed layer '+artboard_metadata+' '+[thisArtboard children])
     states_metadata[SanitizedArtboardName] = lookForStates(artboard_metadata[0],states_metadata[SanitizedArtboardName], true);

    /* Don't use this to export image at all anymore
    log('Multistate: Exporting layers '+artboardId+' '+thisArtboard)
    for (var i=0; i < [all_layers count]; i++) {
      if(artboardId === artboardCount-1){
        log('Multistate: Main Artboard '+artboardId+' '+thisArtboard)
        process_layer(page, all_layers[i],project_metadata, 0, true);
      }
    }
    */
  }
}
function process_layer(page, layer,metadata_container,depth,skipExport) {
  log("Processing layer: " + layer+' skipping: '+skipExport+' type: '+layer.name())
  
  
  log("Metadata Container: " + metadata_container)
  depth++

  if(should_ignore_layer(layer)) {
    log_depth("Ignoring <" + [layer name] + "> of type <" + [layer className] + ">", depth)
    return;
  }


  if(should_become_view(layer)){
    log_depth("Processing <" + [layer name] + "> of type <" + [layer className] + ">", depth)

    if (![layer isVisible]) {
      log_depth("Temporarily showing " + layer,depth)
      [layer setName:[layer name] + "&"]
    }
    [layer setIsVisible:true]

    // Get layer data
    var layer_data = extract_metadata_from(layer)
    layer_data.children = []

    // Export image if layer has no subgroups
    if (!should_flatten_layer(layer) && is_group(layer)) {
      var sublayers = [layer layers];
      // Apparently, Sketch returns child layers in reverse order (back to front),
      // so we'll loop backwards through them:
      for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
        var current = sublayers[sub];
        process_layer(page,current,layer_data.children,depth+1,skipExport);
      }
    }

    // Capture hierarchy in export
    if(layer.parentGroup){
      var parentGroup = layer.parentGroup()
      if(![parentGroup isMemberOfClass:[MSArtboardGroup class]] || ![parentGroup isMemberOfClass:[MSPage class]]){
        log('Setting layer hierarchy name '+parentGroup.name().toString());
        layer_data.parentGroup = parentGroup.name().toString()
      }
    }


    if(!skipExport){
      if ([layer className] == "MSArtboardGroup") {
        export_artboard(layer)
      } else {
        log('using API '+[NSApp applicationVersion])
        if (parseInt([NSApp applicationVersion]) >= 3) {
          log('look for CSS Box:'+layer)
          var CSSBoxBackground = lookForCSSBoxBackground(layer)
          log('look for CSS Box found:'+CSSBoxBackground)
          if(CSSBoxBackground == false){
            export_isolated_layer_v3(page, layer,images_folder + "/" + sanitize_filename([layer name]) + ".png")
          }else{
            layer_data.styles = extract_style_from(CSSBoxBackground);

            var shadow = extract_shadow_from(layer)
            if(shadow){
              layer_data.styles['boxShadow'] = shadow;
              log('putting shadow into layerFrame'+shadow)
            }

            var shadowObjects = layer.style().shadows().array()
  
            for(var i=0;i<shadowObjects.length;i++){
              var shadowObject =shadowObjects[i]
              layer.style().shadows().removeStylePart(shadowObject)
            }

            delete layer_data.image;
            delete layer_data.imageType;
          }
        } else {
          export_isolated_layer_v2(layer,images_folder + "/" + sanitize_filename([layer name]) + ".png")
        }
      }
    }

    // FIXME: why is this here? Still needed?
    // if(should_flatten_layer(layer)){
    //   duplicate_and_export(layer)
    // }
    metadata_container.push(layer_data);

    
    if ([layer name].slice(-1) == '&') {
      log("Restore visibility for " + [layer name])
      [layer setName:[layer name].slice(0, -1)];
      //[layer setIsVisible:false]
      //log("Small hack: this forces a redraw")
      // Small hack: this forces a redraw
      //[layer resetPointsBasedOnUserInteraction]
      log("Now visible")
    }
    log([layer isVisible])
    
  }
}

function create_files(page,metadata,states_metadata){
  log("create_files("+metadata+")")
  var file_path = framer_folder + "/views." + document_name + ".js";
  log(JSON.stringify(metadata))
  var file_contents = "window.FramerPS = window.FramerPS || {};\n"
    +"window.FramerPS['" + document_name +"'] = " + JSON.stringify(metadata,null,2)+"\n"
    save_file_from_string(file_path,file_contents);

    if([[page artboards] count] > 0){
      file_path = framer_folder + "/states." + document_name + ".js";
      file_contents = "window.FramerStates = window.FramerStates || {};\n"
      +"window.FramerStates = " + JSON.stringify(states_metadata,null,2)+"\n";
      save_file_from_string(file_path,file_contents);

      /* I used to put all the state logic into the file directly
      file_contents = "window.FramerStates = window.FramerStates || {};\n"
      +"window.FramerStates = " + JSON.stringify(states_metadata,null,2)+"\n"
      +"Framer.config.animationCurve = 'linear';"
      +"Framer.config.animationDelay = 0;"
      +"Framer.config.animationTime = 300;"
      +"var FramerCurves = (FramerCurves) ? FramerCurves : {linear  : 'spring(400,30,200)',easeIn  : 'ease-in',easeOut : 'ease-out',spring  : 'spring(400,30,200)'}; View.prototype.ani = function(props,time,delay,curve) { if(!curve) curve = Framer.config.animationCurve; console.log(time,delay,curve,props,(!time));if(!time) time = Framer.config.animationTime; var that = this; if(delay > 0){ var a = new Animation({view:this, time: time, curve: curve, properties: props });utils.delay(Framer.config.animationDelay,function(){a.start()})}else{var a = this.animate({ time: time, curve: curve, properties: props });}return a;};\n"

      +"for(var i in FramerCurves) View.prototype[i] = function(props,time,delay) { return this.ani(props,time,delay,FramerCurves[i])};\n"

      +"var setUpStateTransitions = function (){var stateTransitions = [];var makeStateShift = function (state,name){;return function(){for (var i in state){var time = state[i].time || Framer.config.animationTime;var delay = state[i].delay || Framer.config.animationDelay;var curve = state[i].curve || Framer.config.animationCurve;PSD[i].ani(state[i].frame,time,delay,curve)}}};for(var i in FramerStates){var f = makeStateShift(FramerStates[i],i);stateTransitions.push(f)};return stateTransitions;};\n"

      +"var FramerStateShift = utils.cycle(setUpStateTransitions());FramerStateShift()();\n"
      save_file_from_string(file_path,file_contents);
      */
    }
    

  

  log(framer_folder)
  try {
    // Save JS files from templates:
    /*
    save_file_from_string(framer_folder + "/framerps.js", FramerPSJSContents);
    if(![file_manager fileExistsAtPath:(target_folder + "/" + FramerScriptFileName)]) {
      save_file_from_string(target_folder + "/" + FramerScriptFileName, FramerScriptFileContents);
    }
    */
  } catch(e) {
    log(e)
  }

  // Get JS files from Github
  var task = [[NSTask alloc] init],
      argsArray = [NSArray arrayWithObjects:"-O", framerjs_url, nil];
  [task setCurrentDirectoryPath:framer_folder];
  [task setLaunchPath:"/usr/bin/curl"];
  [task setArguments:argsArray];
  [task launch];

  // Get library files if one if configured and isn't yet downloaded
  if(FramerLibraryUrl) {
    if(![file_manager fileExistsAtPath:(framer_folder + "/" + FramerLibraryFileName)]) {
      var task2 = [[NSTask alloc] init],
          argsArray = [NSArray arrayWithObjects:"-O", FramerLibraryUrl, nil];
      [task2 setCurrentDirectoryPath:framer_folder];
      [task2 setLaunchPath:"/usr/bin/curl"];
      [task2 setArguments:argsArray];
      [task2 launch];
    }
  }

  // Create HTML and open in default browser if it's the first time we're exporting
  if(![file_manager fileExistsAtPath:(target_folder + "/index.html")]) {
    save_file_from_string(target_folder + "/index.html",  FramerIndexFileContents.replace("{{ views }}",'<script src="framer/views.' + document_name + '.js"></script>\n<script src="framer/states.' + document_name + '.js"></script>'));
    var open_task = [[NSTask alloc] init],
        open_task_args = [NSArray arrayWithObjects:(target_folder + "/index.html"), nil];

    [open_task setCurrentDirectoryPath:framer_folder];
    [open_task setLaunchPath:"/usr/bin/open"];
    [open_task setArguments:open_task_args];
    [open_task launch];
  }
}
function export_isolated_layer_v3(page,layer,filename){
  // Select layer, so we can be sure there's a current artboard
  [layer select:true byExpandingSelection:false]

  // (if there is, indeed, an artboard, that is :)
  if([[page artboards] count] > 0){
    log("Here be artboards")
    var art = [page currentArtboard],
        did_disable_background = false
    if([art includeBackgroundColorInExport]){
      log("Artboard has a background color set to export, so we'll momentarily disable it")
      [art setIncludeBackgroundColorInExport:false]
      did_disable_background = true
    }
  }
  var sublayers = [layer layers]
  var hasMask = false
  var maskLayer = false
  for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
    log('looking for mask in export '+hasMask)
    if(sublayers[sub].hasClippingMask()){
      log('found mask in export'+hasMask)
      sublayers[sub].hasClippingMask = false
      maskLayer = sublayers[sub]
      hasMask = true
    }
  }
  

  var filename = [@"" stringByAppendingString:filename]
  var slice = [[MSSliceMaker slicesFromExportableLayer:layer] firstObject]
  slice.page = page
  var imageData = [MSSliceExporter dataForSlice:slice format:@"png"]
  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission([filename stringByDeletingLastPathComponent], function(){
      if(is_bitmap(layer)){
        [imageData writeBitmapImageToFile:filename atomically:YES]
      }else{
        [imageData writeToFile:filename atomically:YES]  
      }
      
    }, true)
  } else {
    if(is_bitmap(layer)){
      [imageData writeBitmapImageToFile:filename atomically:YES]
    }else{
      [imageData writeToFile:filename atomically:YES]  
    }
  }

  if (did_disable_background) {
    [art setIncludeBackgroundColorInExport:true]
  }

  if(hasMask){
    //layer.hasClippingMask = true
    maskLayer.hasClippingMask = true
  }
}
function export_isolated_layer_v2(layer,filename){
  var filename = [@"" stringByAppendingString:filename]
  var copy = [layer duplicate]
  [[copy frame] setX:-100000]

  var rect = [copy rectByAccountingForStyleSize:[[copy absoluteRect] rect]],
      slice = [GKRect rectWithRect:rect]

  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission([filename stringByDeletingLastPathComponent], function(){
      [doc saveArtboardOrSlice:slice toFile:filename];
    }, true)
  } else {
    [doc saveArtboardOrSlice:slice toFile:filename];
  }

  [copy removeFromParent]
}
function export_artboard(layer){
  log_depth("Exporting artboard: <" + [layer name] + ">");
  var filename = images_folder + "/" + sanitize_filename([layer name]) + ".png",
      hidden_sublayers = []

  var artnames = [],
      has_art = false;

  // Remove subgroups and only leave shapes
  if(is_group(layer) && !should_flatten_layer(layer)) {
    var sublayers = [layer layers]

    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
      var sublayer = sublayers[sub];
      if(should_become_view(sublayer) || should_ignore_layer(sublayer)) {
        log("     REMOVING " + [sublayer name])
        [sublayer setIsVisible:false]
        hidden_sublayers.push(sublayer)
      } else {
        log("     KEEPING " + [sublayer name]);
        artnames.push([sublayer name])
        has_art = true
      }
    }
  } else {
    // not a group, single art
    has_art = true;
  }

  // Export
  if(!has_art) {
    log("Exporting <" + [layer name] + ">, no image");
  } else {
    log("Exporting <" + [layer name] + "> including children art (" + artnames.join(", ") + ")");

    var slice = [MSSlice sliceWithRect:[[layer absoluteRect] rect] scale:2]

    if (in_sandbox()) {
      sandboxAccess.accessFilePath_withBlock_persistPermission([filename stringByDeletingLastPathComponent], function(){
        [doc saveArtboardOrSlice:slice toFile:filename];
      }, true)
    } else {
      [doc saveArtboardOrSlice:slice toFile:filename];
    }
  }
  // Restore
  log("Restoring formerly visible elements: " + hidden_sublayers.length)
  if(hidden_sublayers.length > 0){
    for (var i = 0; i < hidden_sublayers.length; i++) {
      var l = hidden_sublayers[i]
      [l setIsVisible:true]
    }
    hidden_sublayers = []
  }
}

function lookForCSSBoxBackground(layer){
  log('Looking for CSS Box in '+layer)
  log('Looking for CSS Box in children '+layer.children().length)
  var layerChildren = layer.children()

  var CSSBoxBackground = false;


  if(layerChildren.length > 0){
    log('Looking for CSS Box in layer that has children')
    for (var layerIndex =0;layerIndex < layerChildren.length; layerIndex++){
      var child = layerChildren[layerIndex]
      log('Looking for CSS Box child is '+ layerIndex + ' ' +child.class())
      
      if(child.class() == 'MSShapeGroup' && layerIndex < 2 && !child.hasClippingMask()){
        log('CSS Box found background shape  '+ child)
        CSSBoxBackground = child
      }

      var layerObject = layerChildren[layerIndex]
      var frameName = layerObject.name
    }
  }

  return CSSBoxBackground;

}

function lookForStates(layer,metadata,isRoot){
  log('Looking in: '+layer+' with '+layer.children.length+' children');
  if(layer.children.length > 0){
    for (var j =0;j < layer.children.length; j++){
      var layerObject = layer.children[j]
      var frameName = layerObject.name

      var child = {}

      if(frameName.indexOf('delay') > -1){
        log('Automagic: Delay '+layerObject.name.match(/delay([0-9]*)/)[1])
        child.delay = parseInt(frameName.match(/delay([0-9]*)/)[1])
        frameName = frameName.replace(/_?delay([0-9]*)_?/,"")
      }
      if(frameName.indexOf('time') > -1){
        log('Automagic: Time '+layerObject.name.match(/time([0-9]*)/)[1])
        child.time = parseInt(frameName.match(/time([0-9]*)/)[1])
        frameName = frameName.replace(/_?time([0-9]*)_?/,"")
      }
      if(frameName.indexOf('spring') > -1){
        log('Automagic: spring '+layerObject.name)
        child.curve = 'spring(400,30,200)'
        frameName = frameName.replace(/_?spring?/,"")
      }
      if(frameName.indexOf('ease-in') > -1){
        log('Automagic: ease-in '+layerObject.name)
        child.curve = 'ease-in'
        frameName = frameName.replace(/_?ease-in?/,"")
      }
      if(frameName.indexOf('ease-out') > -1){
        log('Automagic: ease-out '+layerObject.name)
        child.curve = 'ease-out'
        frameName = frameName.replace(/_?ease-out?/,"")
      }
      
      //child.styles = layer.children[j].layerFrame;

      child.frame = layer.children[j].layerFrame;
      
      if(!isRoot){
        child.frame.x -= layer.layerFrame.x;
        child.frame.y -= layer.layerFrame.y;
      }

      if(child.maskFrame){
        /*
        [current setHasClippingMask:false]
        var maskParent = current.parentGroup();
        var maskParentFrame = maskParent.frame();
        maskParent.resizeRoot()
        maskParentFrame.x = 0
        AssetsOffset += maskParentFrame.height() - layerFrame.height()
        [current setHasClippingMask:true]
        child.maskFrame.x -= layer.layerFrame.x
        child.maskFrame.y -= layer.layerFrame.y
        */
      }

      child.parentGroup = layerObject.parentGroup

      metadata[frameName] =child;

      if(layer.children[j].children.length>0){
        metadata = lookForStates(layer.children[j],metadata,false)  
      }
    }
  }
  
  return metadata;
}

function findAssetsPage(focusPage, firstArtboard){
  var assetsPage = false
  var allPages = [doc pages];
  for(var p=0; p < [allPages count]; p++){
    var currentPage = allPages[p]
    log('looking for asset page: '+currentPage+' name: '+currentPage.name()+' = '+(currentPage.name() == 'FramerComponents'))
    if(currentPage.name() == 'FramerComponents'){
      assetsPage = currentPage;
    }
  }
  return assetsPage;
}
function updateAssetsPage(focusPage, firstArtboard){
  var assetsPage = findAssetsPage(focusPage, firstArtboard)
  if(assetsPage!=false){
    log('removing asset page: '+assetsPage+' name: '+assetsPage.name())
    doc.removePage(assetsPage)
  }

  assetsPage = [doc addBlankPage]
  assetsPage.setName("FramerComponents")

  var copyOfArtboard = [firstArtboard copy]
  
  log('looking at artboard copy ' + copyOfArtboard)

  assetsPage.addLayer(copyOfArtboard)
  var copyOfArtboardLayers = copyOfArtboard.layers()
  //var firstArtboardLayers = firstArtboard.layers()
  log('looking at layers '+copyOfArtboardLayers)

  for(var l=0; l < [copyOfArtboardLayers count]; l++){
    addLayerToAssetsPage(copyOfArtboardLayers[l],assetsPage)
  }
  log('added all layers to asset page')

  [copyOfArtboard removeFromParent]

  return assetsPage;
  
}
function addLayerToAssetsPage(layer,assetsPage){

    log('adding layer is group: '+ is_group(layer) +' is view: '+ should_become_view(layer)+' layer:'+layer)
    if (is_group(layer) && should_become_view(layer)) {
      //var layer = layer //[ copy]
      //layer.removeFromParent()
      var styles = {}

      assetsPage.addLayer(layer)

      //assetsPage.resizeRoot()
      layer.style().contextSettings().opacity = 1
      //[assetsPage resetPointsBasedOnUserInteraction] //force redraw
      //var assetsLayers = assetsPage.layers()
      
      //assetsPage.layers().length*1000;
      //if(assetsLayers.length>1){
        //layer.parentGroup().resizeRoot()  
        // log('getting offset: '+assetsLayers[0])
        //var AssetsOffset = assetsLayers[assetsLayers-1].frame().height()
      //}
      
      log('added layer: '+layer+' with children: '+layer.children())

      layerFrame = layer.frame()
      layerFrame.y = 0;
      //log('moving layer: '+layer+' '+layerFrame.height() +' to '+assetsPage)
      layerFrame.x = 0
      layerFrame.y = AssetsOffset + 48

      var label = assetsPage.addLayerOfType("text");
      var layerName = (layer.name()) ? layer.name() : 'Undefined layer';
      label.setName("label for "+layerName);
      //var label = [MSTextLayer]
      log("created text "+label)
      label.fontSize = 11;
      label.fontPostscriptName = "Lucida Grande"
      var fontColor = [[MSColor alloc] init];
      [fontColor setRed:0.45];
      [fontColor setGreen:0.45];
      [fontColor setBlue:0.45];
      [fontColor setAlpha:1];

      label.textColor = fontColor

      log("changed font text "+label)
      label.setStringValue(layerName)
      log("set value of text "+label)
      labelFrame = label.frame()
      labelFrame.y = AssetsOffset + 30
      log("set frame of text "+label)
      //assetsPage.addLayer(label)
      
      //AssetsOffset += layerFrame.height() + 56
      AssetsOffset += layerFrame.height() + 56
      
    
      var sublayers = layer.layers();
      // Apparently, Sketch returns child layers in reverse order (back to front),
      // so we'll loop backwards through them:
      for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
        var current = sublayers[sub];
        if(is_group(current) && should_become_view(current)){
          //var currentDup = [current duplicate]
          current.removeFromParent()
          addLayerToAssetsPage(current,assetsPage)
          //currentDup.removeFromParent()
        }
        if(current.hasClippingMask()) {
          log('Moved masked layer to assets: '+current)
          [current setHasClippingMask:false]
          var maskParent = current.parentGroup();
          var maskParentFrame = maskParent.frame();
          maskParent.resizeRoot()
          maskParentFrame.x = 0
          AssetsOffset += maskParentFrame.height() - layerFrame.height()
          [current setHasClippingMask:true]
        }
      } 
    }
    
    
}


var document_path = [[doc fileURL] path].split([doc displayName])[0],
    document_name = [doc displayName].replace(".sketch",""),
    target_folder = document_path + document_name,
    images_folder = target_folder + "/images",
    framer_folder = target_folder + "/framer",
    file_manager = [NSFileManager defaultManager],
    invisible_layers = [],
    project_metadata = [],
    states_metadata = {},
    AssetsOffset = 0;

function main() {

  log('########################################################################');
  
  var focusPage = [doc currentPage]
  var currentArtboards = [focusPage artboards]
  var firstArtboard = [currentArtboards firstObject]
  var allPages = [doc pages];

  make_folders()

  if([currentArtboards count] > 0){

    var assetsPage = updateAssetsPage(focusPage, firstArtboard);
    process_all_artboards(focusPage);
    log('Auto assets: Made states, search for Assets');
    
    process_all_layers(assetsPage);
    create_files(focusPage, project_metadata, states_metadata)
    log('trying to deselect Layers')

    //[focusPage deselectAllLayers]
      
    log('trying to refocus on: '+focusPage)

    //[focusPage select:true byExpandingSelection:false]
    //[firstArtboard select:true byExpandingSelection:false]
    [doc setCurrentPage:focusPage]

    // Display message in toolbar
    [doc showMessage: "Sketch Framer: Project exported to “" + target_folder + "”"];
    
  }else{
    //var assetsPage = findStatesPage(focusPage, firstArtboard);
    // Display message in toolbar
    [doc showMessage: "Sketch Framer: You must have multiple artboards for this to work"];
  }

}

/*

This plugin will export your Sketch document to a Framer project.

This command REQUIRES at least Sketch Version 2.3 (419),
as it uses an API not available in earlier versions

- Every layer group will become an ImageView, backed by the pixel and/or shape layers in that layer group.
- Views are accessible by name under the PSD object (yeah, I know...)
- Framer respects the layer hierarchy, so a sub layer group will become a subview. This way you can define your view structure in Photoshop.
- TODO: Layer groups with vector masks will become views with clipping enabled. You can optionally add "scroll" to the layer group name to make it a ScrollView.
- Layer group names should be unique, if they're not Framer will silently rename them on export.

// TODO: Check for duplicated names in exported files
// TODO: Calculate proper IDs (not sure what they're used for, but hey...)
// TODO: Calculate proper modification hash
// TODO: Embed framer.js on this file, instead of 'curl'ing it from Github
// TODO: Multiple Artboards support

*/

main();
